{
  "name": "Crypto Trading Bot - Gemma-2-2b-it",
  "nodes": [
    {
      "parameters": {},
      "id": "manual_trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [240, 400]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://raw.githubusercontent.com/dryjins/aib/main/2026/l4/crypto_features_3months.csv",
        "options": {}
      },
      "id": "load_features",
      "name": "Load Market Data (GitHub)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [460, 400]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://raw.githubusercontent.com/dryjins/aib/main/2026/l4/crypto_news_3months.csv",
        "options": {}
      },
      "id": "load_news",
      "name": "Load News Data (GitHub)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [460, 600]
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first();\nlet text = '';\n\nif (typeof input.json === 'string') {\n  text = input.json;\n} else if (input.json.data) {\n  text = input.json.data;\n} else if (input.binary && input.binary.data) {\n  text = Buffer.from(input.binary.data.data, 'base64').toString('utf-8');\n} else {\n  text = JSON.stringify(input.json);\n}\n\nconst lines = text.split('\\n').filter(l => l.trim());\nif (lines.length === 0) {\n  throw new Error('Empty CSV data');\n}\n\nconst headers = lines[0].split(',').map(h => h.trim());\n\nconst result = [];\nfor (let i = 1; i < lines.length; i++) {\n  const line = lines[i];\n  if (!line.trim()) continue;\n  \n  const values = [];\n  let current = '';\n  let inQuotes = false;\n  \n  for (let char of line) {\n    if (char === '\"') {\n      inQuotes = !inQuotes;\n    } else if (char === ',' && !inQuotes) {\n      values.push(current.trim());\n      current = '';\n    } else {\n      current += char;\n    }\n  }\n  values.push(current.trim());\n  \n  const obj = {};\n  headers.forEach((h, idx) => {\n    obj[h] = values[idx] || '';\n  });\n  \n  result.push({ json: obj });\n}\n\nreturn result;"
      },
      "id": "parse_features",
      "name": "Parse Market CSV",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 400]
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first();\nlet text = '';\n\nif (typeof input.json === 'string') {\n  text = input.json;\n} else if (input.json.data) {\n  text = input.json.data;\n} else if (input.binary && input.binary.data) {\n  text = Buffer.from(input.binary.data.data, 'base64').toString('utf-8');\n} else {\n  text = JSON.stringify(input.json);\n}\n\nconst lines = text.split('\\n').filter(l => l.trim());\nif (lines.length === 0) {\n  throw new Error('Empty CSV data');\n}\n\nconst headers = lines[0].split(',').map(h => h.trim());\n\nconst result = [];\nfor (let i = 1; i < lines.length; i++) {\n  const line = lines[i];\n  if (!line.trim()) continue;\n  \n  const values = [];\n  let current = '';\n  let inQuotes = false;\n  \n  for (let char of line) {\n    if (char === '\"') {\n      inQuotes = !inQuotes;\n    } else if (char === ',' && !inQuotes) {\n      values.push(current.trim());\n      current = '';\n    } else {\n      current += char;\n    }\n  }\n  values.push(current.trim());\n  \n  const obj = {};\n  headers.forEach((h, idx) => {\n    obj[h] = values[idx] || '';\n  });\n  \n  result.push({ json: obj });\n}\n\nreturn result;"
      },
      "id": "parse_news",
      "name": "Parse News CSV",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 600]
    },
    {
      "parameters": {
        "jsCode": "const newsByDate = {};\n\nfor (const item of $input.all()) {\n  const date = item.json.date;\n  if (!newsByDate[date]) {\n    newsByDate[date] = [];\n  }\n  newsByDate[date].push({\n    title: item.json.title || '',\n    body: item.json.body || ''\n  });\n}\n\nreturn [{ json: { newsByDate } }];"
      },
      "id": "group_news",
      "name": "Group News by Date",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 600]
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\nlet newsLookup = {};\nfor (const item of items) {\n  if (item.json.newsByDate) {\n    newsLookup = item.json.newsByDate;\n    break;\n  }\n}\n\nconst merged = [];\nfor (const item of items) {\n  if (item.json.newsByDate) continue;\n  \n  const date = item.json.date;\n  const news = newsLookup[date] || [];\n  \n  const newsText = news.length > 0 \n    ? news.map(n => `${n.title}: ${n.body.substring(0, 200)}`).slice(0, 3).join('\\n\\n')\n    : 'No significant news today';\n  \n  merged.push({\n    json: {\n      ...item.json,\n      news_text: newsText,\n      news_count: news.length\n    }\n  });\n}\n\nreturn merged;"
      },
      "id": "merge_data",
      "name": "Merge Market + News",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 400]
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json;\n\n// –§–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–æ–º–ø—Ç –¥–ª—è Gemma\nconst prompt = `<start_of_turn>user\nYou are a cryptocurrency analyst. Analyze this data and output ONLY valid JSON.\n\nDate: ${data.date}\nCoin: ${data.ticker}\n\nNews:\n${data.news_text}\n\nMarket Data:\n- Price: $${data.close}\n- RSI: ${data.rsi}\n- MACD: ${data.macd_hist}\n- BB Position: ${data.bb_position}\n\nOutput JSON in this exact format:\n{\n  \"sentiment_score\": (float between -1 and 1),\n  \"market_mood\": \"bullish\" or \"bearish\" or \"neutral\",\n  \"recommended_action\": \"buy\" or \"sell\" or \"hold\",\n  \"confidence\": (float between 0 and 1),\n  \"reasoning\": \"short reason\"\n}\n<end_of_turn>\n<start_of_turn>model\n`;\n\nreturn [{\n  json: {\n    ...data,\n    prompt: prompt\n  }\n}];"
      },
      "id": "llm_prompt",
      "name": "üéØ MODIFY: LLM Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://router.huggingface.co/google/gemma-2-2b-it",
        "sendBody": true,
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer YOUR_HF_TOKEN_HERE"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "specifyBody": "json",
        "jsonBody": "{\n  \"inputs\": \"{{ $json.prompt }}\",\n  \"parameters\": {\n    \"max_new_tokens\": 300,\n    \"temperature\": 0.3,\n    \"return_full_text\": false\n  }\n}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "call_gemma",
      "name": "Call Gemma-2 (HF)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1560, 400]
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json;\nlet analysis = {};\n\ntry {\n  // –û—Ç–≤–µ—Ç –æ—Ç HF\n  const hfResponse = Array.isArray(data) ? data[0] : data;\n  let generatedText = hfResponse.generated_text || '';\n  \n  // –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ JSON –≤ —Ç–µ–∫—Å—Ç–µ\n  const jsonMatch = generatedText.match(/\\{.*\\}/s);\n  if (jsonMatch) {\n    analysis = JSON.parse(jsonMatch[0]);\n  } else {\n    throw new Error(\"No JSON found in response\");\n  }\n} catch (e) {\n  analysis = {\n    sentiment_score: 0,\n    market_mood: \"neutral\",\n    recommended_action: \"hold\",\n    confidence: 0,\n    reasoning: `Parse error: ${e.message}`\n  };\n}\n\n// –í–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —É–∑–ª–∞\nreturn [{\n  json: {\n    date: data.date,\n    ticker: data.ticker,\n    price: parseFloat(data.close),\n    analysis: analysis,\n    indicators: {\n      rsi: parseFloat(data.rsi || 0),\n      macd_hist: parseFloat(data.macd_hist || 0),\n      bb_position: parseFloat(data.bb_position || 0),\n      volatility: parseFloat(data.volatility_7d || 0)\n    }\n  }\n}];"
      },
      "id": "parse_response",
      "name": "Parse LLM Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1780, 400]
    },
    {
      "parameters": {
        "jsCode": "// ========================================\n// üéØ STUDENTS: MODIFY THIS LOGIC\n// ========================================\n\nconst { analysis, indicators, date, ticker, price } = $input.first().json;\n\nconst sentiment = parseFloat(analysis.sentiment_score) || 0;\nconst confidence = parseFloat(analysis.confidence) || 0;\nconst rsi = parseFloat(indicators.rsi) || 0;\nconst bb_pos = parseFloat(indicators.bb_position) || 0;\nconst volatility = parseFloat(indicators.volatility) || 0;\n\nlet decision = \"hold\";\nlet reason = \"Neutral conditions\";\n\n// Risk management: avoid high volatility\nif (volatility > 0.07) {\n  decision = \"hold\";\n  reason = \"High volatility - risk off\";\n}\n// Buy conditions\nelse if (sentiment > 0.5 && confidence > 0.6 && rsi < 70 && bb_pos < 0.8) {\n  decision = \"buy\";\n  reason = \"Positive sentiment + healthy RSI\";\n} \n// Sell conditions\nelse if (sentiment < -0.3 || rsi > 75) {\n  decision = \"sell\";\n  reason = \"Negative sentiment or overbought\";\n} \n// Emergency sell\nelse if (rsi > 85) {\n  decision = \"sell\";\n  reason = \"Emergency stop-loss (extreme overbought)\";\n}\n\nreturn [{\n  json: {\n    date: date || 'N/A', \n    ticker: ticker || 'N/A', \n    price: price || 0, \n    decision, \n    reason,\n    sentiment: sentiment.toFixed(3), \n    rsi: rsi.toFixed(2),\n    confidence: confidence.toFixed(3)\n  }\n}];"
      },
      "id": "trading_logic",
      "name": "üéØ MODIFY: Trading Logic",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 400]
    },
    {
      "parameters": {
        "jsCode": "const trades = $input.all();\n\nconst buys = trades.filter(t => t.json.decision === 'buy').length;\nconst sells = trades.filter(t => t.json.decision === 'sell').length;\nconst holds = trades.filter(t => t.json.decision === 'hold').length;\n\nconst csvHeader = 'date,ticker,price,decision,reason,sentiment,rsi,confidence\\n';\nconst csvRows = trades.map(t => {\n  const j = t.json;\n  return `${j.date},${j.ticker},${j.price},${j.decision},\"${j.reason}\",${j.sentiment},${j.rsi},${j.confidence}`;\n}).join('\\n');\n\nconst csvContent = csvHeader + csvRows;\n\nreturn [{\n  json: {\n    total_trades: trades.length,\n    buys: buys,\n    sells: sells,\n    holds: holds,\n    message: `Backtest complete! ${buys} buys, ${sells} sells, ${holds} holds`\n  },\n  binary: {\n    data: {\n      data: Buffer.from(csvContent).toString('base64'),\n      mimeType: 'text/csv',\n      fileName: 'trades_log.csv'\n    }\n  }\n}];"
      },
      "id": "export_csv",
      "name": "Export trades_log.csv",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2220, 400]
    }
  ],
  "connections": {
    "Manual Trigger": {
      "main": [
        [
          { "node": "Load Market Data (GitHub)", "type": "main", "index": 0 },
          { "node": "Load News Data (GitHub)", "type": "main", "index": 0 }
        ]
      ]
    },
    "Load Market Data (GitHub)": {
      "main": [
        [
          { "node": "Parse Market CSV", "type": "main", "index": 0 }
        ]
      ]
    },
    "Load News Data (GitHub)": {
      "main": [
        [
          { "node": "Parse News CSV", "type": "main", "index": 0 }
        ]
      ]
    },
    "Parse Market CSV": {
      "main": [
        [
          { "node": "Merge Market + News", "type": "main", "index": 0 }
        ]
      ]
    },
    "Parse News CSV": {
      "main": [
        [
          { "node": "Group News by Date", "type": "main", "index": 0 }
        ]
      ]
    },
    "Group News by Date": {
      "main": [
        [
          { "node": "Merge Market + News", "type": "main", "index": 0 }
        ]
      ]
    },
    "Merge Market + News": {
      "main": [
        [
          { "node": "üéØ MODIFY: LLM Prompt", "type": "main", "index": 0 }
        ]
      ]
    },
    "üéØ MODIFY: LLM Prompt": {
      "main": [
        [
          { "node": "Call Gemma-2 (HF)", "type": "main", "index": 0 }
        ]
      ]
    },
    "Call Gemma-2 (HF)": {
      "main": [
        [
          { "node": "Parse LLM Response", "type": "main", "index": 0 }
        ]
      ]
    },
    "Parse LLM Response": {
      "main": [
        [
          { "node": "üéØ MODIFY: Trading Logic", "type": "main", "index": 0 }
        ]
      ]
    },
    "üéØ MODIFY: Trading Logic": {
      "main": [
        [
          { "node": "Export trades_log.csv", "type": "main", "index": 0 }
        ]
      ]
    }
  }
}
